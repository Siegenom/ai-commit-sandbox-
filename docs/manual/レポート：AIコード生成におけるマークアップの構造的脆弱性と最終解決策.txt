レポート：AIコード生成における、ネストされたマークアップの構造的脆弱性と最終解決策

## 1. はじめに

AIが生成したコードが、それを表示するUIや、実行する言語のパーサー（構文解析エンジン）によって正しく解釈されず、予測不能なエラーを引き起こすという、根深い問題が存在します。このレポートでは、その根本原因と、それを恒久的に回避するための解決策を、2つの具体的な事例と、それらが顕在化した環境の分析を通じて詳述します。

---

## 2. 問題の分析 - 2つの事例
  
### 事例1：Gemini Code Assist: chatにおけるUIレンダリングの破綻
 
*   **症状:** Gemini Code AssistのチャットUI上で、AIが生成したコードブロックが正しく表示されず、UIの表示崩壊や応答の途絶が発生しました。
*   **原因:** UIを構成する`WebView`（組み込みブラウザ）のレンダリングエンジンが、コード内の文字列（例: ```）を誤ってMarkdownとして解釈し、HTML（DOM）構造を破壊したためです。

### 事例2：PowerShellにおけるヒアドキュメントの解析失敗

*   **症状:** 特定のPowerShellスクリプトを実行した際に、`文字列に終端記号 " がありません。` という致命的なエラーが発生しました。
*   **原因:** PowerShellのパーサー自体が、ヒアドキュメント内部に混在する複雑な文字列（Markdownのコードフェンス等）の解析に失敗し、後続のコードを文字列の一部と誤認したためです。これはUIの問題ではなく、言語のパーサーそのものの脆弱性です。

---

## 3. なぜ「Gemini Code Assist: chat」で問題が顕在化したのか？

今回の問題、特に事例1は、他の環境（CLI、通常のWeb UI）では発生しませんでした。その理由は、各環境のアーキテクチャの違いにあります。

*   **CLI:** レンダリングという概念がなく、生テキストを扱うため問題は発生しません。
*   **Web UI:** 非常に堅牢でエラー耐性の高い標準ブラウザエンジンで動作するため、多少の構造の矛盾は許容されます。
*   **Gemini Code Assist: chat:** IDEに組み込まれた、特殊で繊細な`WebView`上で動作します。この環境の**比較的脆弱なレンダリングエンジン**が、今回の問題の引き金となりました。

しかし、これは「Code Assistだけの問題」と切り捨てるべきではありません。むしろ、この**特殊な環境が、他の環境では潜在化していた「危険な構造」の脆弱性を、我々の目の前に浮かび上がらせてくれた**と捉えるべきです。 

---

## 4. 結論：普遍的な脆弱性としての「危険な構造」

### 4.1. 「危険な構造」の定義

上記2つの事例の根本原因は、**「ホスト言語（例: PowerShell）のコード内に、ゲスト言語（例: Markdown）のマークアップがリテラルとして混在している」**という、**「危険な構造」**に集約されます。

### 4.2. 普遍的なリスク

この構造は、たとえ特定の環境で問題なく動作しているように見えても、本質的に以下のリスクを内包しています。

*   **未知の脆弱性:** 将来のツールや、既存ツールのアップデートによって、新たなバグの引き金となる可能性があります。
*   **保守性の低下:** コードの可読性を損ない、将来の修正を困難にします。
*   **移植性の欠如:** 他のシステムへコードを移植する際の障害となる可能性があります。

### 4.3. 恒久的な解決策：「テンプレートとデータの分離」

この問題を恒久的に解決するための唯一の方法は、AIがコードを生成する際に、この**「危険な構造」を完全に排除する**ことです。そのための最も堅牢な設計パターンが、**「テンプレートとデータの分離」**です。ヒアドキュメントのような曖昧な構文を避け、文字列配列の結合やフォーマット関数を用いることで、コードの安全性を飛躍的に高めることができます。

---

## 5. AIへの指示書（自己参照用・改訂版）

*   **原則1: 「危険な構造」の認識:** 複数行文字列の内部に、コードブロック構文や変数展開が混在する状態は「危険な構造」である。これは、**UIレンダリングとホスト言語のパーサーの両方を破壊する**可能性があるため、絶対に避けなければならない。
*   **原則2: 安全な代替案の義務化:** 「危険な構造」を持つコードを生成してはならない。常に「テンプレートとデータの分離」パターン（文字列配列の結合や-f演算子など）を用いて、構文的に安全なコードを生成すること。
*   **原則3: 自己修正の徹底:** もし「危険な構造」を生成しそうになった場合は、出力前に必ず自己修正し、安全な代替案に書き換える。このプロセスをユーザーに通知する必要はない。