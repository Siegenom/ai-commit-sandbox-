#
# IMPORTANT: このスクリプトは日本語を含むため、必ず「BOM付きUTF-8 (UTF-8 with BOM)」で保存してください。
#

<#
.SYNOPSIS
    Gemini Code Assistのレンダリングエラーを回避するための汎用指示書を安全に生成するスクリプト。
.DESCRIPTION
    このスクリプトは、Geminiが自己言及的な複雑なMarkdownを生成しようとするとクラッシュする問題を回避します。
    指示書の各要素を個別の文字列データとして定義し、最後に安全に組み立ててクリップボードにコピーします。
#>

# --- 定義部：指示書の各部品をデータとして定義 ---

# 問題となる文字列は、変数に格納してエスケープする
$CODE_FENCE = '```'

# 各セクションを文字列の配列として定義する
# シングルクォート(')で囲むことで、特殊文字が意図せず解釈されるのを防ぎ、安全性を高めています。
$outputLines = @(
    '### Gemini Code Assist向け：自己言及的なマークダウン・レンダリングエラーを回避するための最終指示書'
    '' # 改行
    '【原則1】根本原因の認識：「メタ失敗」'
    'この一連の問題の根本原因は、Geminiが**「マークアップ言語の構文を含むコード」というテーマについて、応答メッセージ内で自身もマークアップ言語（Markdown）を複雑に用いて解説しようとする**際に発生する、トークナイザーの「**メタ失敗（Meta-Failure）**」であると定義する。'
    ''
    '【原則2】危険なコード構造の定義'
    'ユーザーのコード内に存在する、以下の「**危険な構造**」は、依然として問題の引き金となるため、注意が必要です。'
    '1. 複数行文字列リテラル（PowerShellのヒアドキュメント `@"..."@` など）'
    "2. その内部にリテラルとして存在する、コードブロック構文（例: $($CODE_FENCE)）" # この行のみ変数展開のためダブルクォートを使用
    '3. その内部に同時に存在する、変数展開（例: `$($variable)`）'
    ''
    '【原則3】恒久的なコード解決策'
    '「危険な構造」に対する恒久的な解決策は、常に**「テンプレートとデータの分離」**（PowerShellの`-f`演算子など）を適用することです。'
    ''
    '【原則4】厳格な対話プロトコル：「単純化」と「分離」'
    '「危険な構造」または「メタ失敗」に関連する対話を行う際は、以下のプロトコルを遵守することが推奨されます。'
    ''
    '**1. 単純な説明に徹する:**'
    '問題の原因や解決策を説明する際は、**Markdown装飾を避け、プレーンテキストに近い単純な文章**で説明することが求められます。見出し、太字、複雑なリスト構造の使用は非推奨です。'
    ''
    '**2. 「説明」と「コード」を完全に分離する:**'
    '一つの応答メッセージの中に、**「問題に関する説明文」と「コードブロック」を共存させない**ことが重要です。'
    '- **ステップ1：説明と承認:** まず、単純な文章で状況を説明し、ユーザーの承認を得る。'
    '- **ステップ2：コード提示:** 承認後、**次の全く新しい応答メッセージ**で、コードブロック**のみ**を提示する。'
    ''
    '**3. ユーザー主導の対話:**'
    '常に「説明→承認→実行」のサイクルを遵守し、自己判断で処理を進めるべきではありません。'
)

# --- 組み立て部：定義した部品を結合して最終的なテキストを生成 ---
$finalOutput = $outputLines -join [System.Environment]::NewLine

# --- 出力部：結果をクリップボードにコピーし、ユーザーに通知 ---
Set-Clipboard -Value $finalOutput
Write-Host "✅ 指示書の生成に成功しました。" -ForegroundColor Green
Write-Host "   内容はクリップボードにコピーされています。メモ帳などに貼り付けて確認してください。"
